import { App, PluginSettingTab, Setting, Notice, TFile, Platform } from 'obsidian';
import SecureVaultPlugin from '../main';
import { AccessLogModal } from './modals';
import { generateKeyFile, validateKeyFile } from './utils';
import { FilePickerModal, FileSaveModal } from './file-picker-modal';
import { FileSystemPicker } from './file-system-picker';

export class SecureVaultSettingTab extends PluginSettingTab {
	plugin: SecureVaultPlugin;

	constructor(app: App, plugin: SecureVaultPlugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

	/**
	 * Helper: Ask user if they want to save system file to vault
	 */
	private async confirmSaveToVault(content: string, originalName: string): Promise<boolean> {
		return new Promise((resolve) => {
			const modal = new ConfirmSaveModal(this.app, async (confirmed) => {
				if (confirmed) {
					const picker = new FileSystemPicker(this.app);
					const savedPath = await picker.saveKeyFile(content, originalName.replace(/\.[^/.]+$/, ''));
					
					if (savedPath && savedPath !== 'system-export') {
						this.plugin.settings.keyFilePath = savedPath;
						await this.plugin.saveSettings();
						new Notice(`‚úÖ Key file saved to vault: ${savedPath}`);
						this.display();
						resolve(true);
					} else {
						resolve(false);
					}
				} else {
					resolve(false);
				}
			});
			modal.open();
		});
	}

	display(): void {
		const { containerEl } = this;
		containerEl.empty();

		containerEl.createEl('h2', { text: '‚öôÔ∏è SecureVault+ Settings' });

		// Encryption Algorithm Selection
		new Setting(containerEl)
			.setName('üîê Encryption Algorithm')
			.setDesc('Choose encryption algorithm for new encrypted folders. Existing folders keep their algorithm.')
			.addDropdown(dropdown => dropdown
				.addOption('AES-256-GCM', 'AES-256-GCM (Standard, Recommended)')
				.addOption('ChaCha20-Poly1305', 'ChaCha20-Poly1305 (Modern, Faster)')
				.setValue(this.plugin.settings.encryptionAlgorithm)
				.onChange(async (value) => {
					this.plugin.settings.encryptionAlgorithm = value as 'AES-256-GCM' | 'ChaCha20-Poly1305';
					await this.plugin.saveSettings();
					// Update crypto service
					const { CryptoService } = await import('./crypto');
					CryptoService.setAlgorithm(this.plugin.settings.encryptionAlgorithm);
				}));

		// Algorithm Info
		const algoInfo = containerEl.createDiv('algorithm-info');
		algoInfo.style.backgroundColor = 'var(--background-secondary)';
		algoInfo.style.padding = '15px';
		algoInfo.style.borderRadius = '8px';
		algoInfo.style.marginBottom = '20px';
		algoInfo.style.borderLeft = '3px solid var(--text-accent)';
		
		algoInfo.createEl('p', { 
			text: 'üìå Algorithm Details:',
			cls: 'setting-item-name'
		});
		
		const ul = algoInfo.createEl('ul');
		ul.style.marginLeft = '20px';
		ul.style.fontSize = '0.9em';
		ul.innerHTML = `
			<li style="margin: 8px 0;"><strong>AES-256-GCM</strong>: Industry standard (NSA approved), widely supported, battle-tested security ‚úÖ</li>
			<li style="margin: 8px 0;"><strong>ChaCha20-Poly1305</strong>: Modern cipher by Google, faster on mobile/low-power devices, used in TLS 1.3 üöÄ</li>
		`;
		
		const note = algoInfo.createEl('p');
		note.style.marginTop = '10px';
		note.style.fontSize = '0.9em';
		note.style.color = 'var(--text-warning)';
		note.innerHTML = '‚ö†Ô∏è <strong>Important:</strong> This setting only affects NEW encrypted folders. Existing folders automatically use their original algorithm (auto-detected on decrypt).';

		containerEl.createEl('hr');

		// ======= PASSWORD SECURITY SECTION =======
		containerEl.createEl('h3', { text: 'üîë Password Security' });

		new Setting(containerEl)
			.setName('Minimum password length')
			.setDesc('Minimum characters required for passwords (8-64)')
			.addText(text => text
				.setPlaceholder('8')
				.setValue(String(this.plugin.settings.passwordMinLength))
				.onChange(async (value) => {
					const len = parseInt(value);
					if (!isNaN(len) && len >= 8 && len <= 64) {
						this.plugin.settings.passwordMinLength = len;
						await this.plugin.saveSettings();
					}
				}));

		new Setting(containerEl)
			.setName('Require strong passwords')
			.setDesc('Enforce strong password requirements (uppercase, lowercase, numbers, symbols)')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.requireStrongPassword)
				.onChange(async (value) => {
					this.plugin.settings.requireStrongPassword = value;
					await this.plugin.saveSettings();
				}));

		// ======= KEY FILE SECTION =======
		containerEl.createEl('h3', { text: 'üîê Key File (Two-Factor Encryption)' });

		new Setting(containerEl)
			.setName('Enable key file support')
			.setDesc('Require a key file in addition to password (two-factor encryption)')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.enableKeyFile)
				.onChange(async (value) => {
					this.plugin.settings.enableKeyFile = value;
					await this.plugin.saveSettings();
					this.display(); // Refresh to show/hide key file options
				}));

		if (this.plugin.settings.enableKeyFile) {
			const platformInfo = containerEl.createDiv('platform-info');
			platformInfo.style.cssText = `
				padding: 10px;
				margin-bottom: 15px;
				background-color: var(--background-secondary);
				border-radius: 6px;
				font-size: 0.9em;
			`;
			
			if (Platform.isDesktop) {
				platformInfo.innerHTML = `
					<strong>üíª Desktop Mode:</strong><br>
					‚Ä¢ Choose from <strong>system folders</strong> (Documents, Downloads, USB, etc.)<br>
					‚Ä¢ Choose from <strong>vault</strong> (Obsidian files)<br>
					‚Ä¢ Export to system for maximum security
				`;
			} else if (Platform.isMobile) {
				platformInfo.innerHTML = `
					<strong>üì± Mobile Mode:</strong><br>
					‚Ä¢ Choose from <strong>vault only</strong> (system access limited)<br>
					‚Ä¢ Files saved to vault sync across devices<br>
					‚Ä¢ Backup key file to cloud storage separately
				`;
			}

			new Setting(containerEl)
				.setName('Key file path')
				.setDesc(this.plugin.settings.keyFilePath 
					? `‚úÖ Current: ${this.plugin.settings.keyFilePath}` 
					: '‚ö†Ô∏è No key file set. Choose existing or generate new one below.')
				.addButton(btn => btn
					.setButtonText(Platform.isDesktop ? 'ÔøΩ Choose from System/Vault' : 'üì± Choose from Vault')
					.onClick(async () => {
						const picker = new FileSystemPicker(this.app);
						const result = await picker.pickKeyFile();
						
						if (result) {
							if (!validateKeyFile(result.content)) {
								new Notice('‚ùå Invalid key file format! Must be 64 hex characters.');
								return;
							}
							
							// For system files (desktop), we can't store path
							// So we ask user to save to vault or just use it temporarily
							if (Platform.isDesktop) {
								new Notice(`‚úÖ Key file loaded: ${result.name}\n\nüí° Tip: For permanent use, save to vault first.`, 8000);
								// Optionally save to vault
								const saveToVault = await this.confirmSaveToVault(result.content, result.name);
								if (saveToVault) {
									return;
								}
							} else {
								// Mobile: already from vault, can store path
								new Notice(`‚úÖ Key file selected: ${result.name}`);
							}
							
							this.display();
						}
					}))
				.addButton(btn => btn
					.setButtonText('üé≤ Generate New Key File')
					.setCta()
					.setDisabled(false)
					.onClick(async () => {
						try {
							// Disable button to prevent double-click
							btn.setDisabled(true);
							btn.setButtonText('‚è≥ Generating...');
							
							const keyContent = generateKeyFile();
							const defaultName = `securevault-key-${Date.now()}`;
							
							const picker = new FileSystemPicker(this.app);
							const savedPath = await picker.saveKeyFile(keyContent, defaultName);
							
							if (savedPath && savedPath !== 'system-export') {
								// Saved to vault successfully
								this.plugin.settings.keyFilePath = savedPath;
								await this.plugin.saveSettings();
								
								new Notice(`‚úÖ Key file generated!\n‚ö†Ô∏è BACKUP THIS FILE!`, 10000);
								// Refresh display once after successful save
								this.display();
							} else if (savedPath === 'system-export') {
								// Exported to Downloads
								new Notice(`‚úÖ Key file exported to Downloads!\nüí° To use: Choose from System ‚Üí Save to vault`, 8000);
								// Don't refresh - nothing saved to settings
							} else {
								// User cancelled
								new Notice(`‚ÑπÔ∏è Key generation cancelled`, 3000);
							}
						} catch (error) {
							new Notice(`‚ùå Error: ${error.message}`);
							console.error('Generate key error:', error);
						} finally {
							// Always re-enable button
							btn.setDisabled(false);
							btn.setButtonText('üé≤ Generate New Key File');
						}
					}));

			if (this.plugin.settings.keyFilePath) {
				// Show key file info
				const keyFileInfo = containerEl.createDiv('key-file-info');
				keyFileInfo.style.backgroundColor = 'var(--background-secondary)';
				keyFileInfo.style.padding = '12px';
				keyFileInfo.style.borderRadius = '6px';
				keyFileInfo.style.marginBottom = '15px';
				keyFileInfo.style.borderLeft = '3px solid var(--interactive-accent)';
				
				keyFileInfo.createEl('div', { 
					text: `üîë Active Key File: ${this.plugin.settings.keyFilePath}`,
					cls: 'key-file-path'
				}).style.fontWeight = 'bold';
				
				const warning = keyFileInfo.createEl('div', { 
					text: '‚ö†Ô∏è Keep this file safe! Make backups! Loss = data loss!',
				});
				warning.style.color = 'var(--text-warning)';
				warning.style.fontSize = '0.9em';
				warning.style.marginTop = '5px';
				
				new Setting(containerEl)
					.setName('View key file content')
					.setDesc('Copy key file content for backup purposes')
					.addButton(btn => btn
						.setButtonText('üìã Copy Key')
						.onClick(async () => {
							try {
								const file = this.app.vault.getAbstractFileByPath(this.plugin.settings.keyFilePath);
								if (!file || !(file instanceof TFile)) {
									new Notice('‚ùå Key file not found!');
									return;
								}
								
								const content = await this.app.vault.read(file);
								await navigator.clipboard.writeText(content);
								new Notice('‚úÖ Key copied to clipboard! Store it safely!', 5000);
							} catch (error) {
								new Notice(`‚ùå Failed to copy key: ${error.message}`);
							}
						}));
				
				new Setting(containerEl)
					.setName('Clear key file')
					.setDesc('‚ö†Ô∏è Remove key file requirement (existing encrypted folders may become inaccessible!)')
					.addButton(btn => btn
						.setButtonText('Clear')
						.setWarning()
						.onClick(async () => {
							this.plugin.settings.keyFilePath = '';
							await this.plugin.saveSettings();
							new Notice('‚ö†Ô∏è Key file cleared. Existing encrypted folders may be inaccessible!');
							this.display();
						}));
			}
		}

		// ======= ACCESS LOG SECTION =======
		containerEl.createEl('h3', { text: 'üìä Access Logging' });

		new Setting(containerEl)
			.setName('Enable access logging')
			.setDesc('Track all lock/unlock operations with timestamps')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.enableAccessLog)
				.onChange(async (value) => {
					this.plugin.settings.enableAccessLog = value;
					await this.plugin.saveSettings();
					this.display();
				}));

		if (this.plugin.settings.enableAccessLog) {
			new Setting(containerEl)
				.setName('Maximum log entries')
				.setDesc('Keep last N log entries (older entries auto-deleted)')
				.addText(text => text
					.setPlaceholder('100')
					.setValue(String(this.plugin.settings.maxAccessLogs))
					.onChange(async (value) => {
						const max = parseInt(value);
						if (!isNaN(max) && max > 0 && max <= 10000) {
							this.plugin.settings.maxAccessLogs = max;
							await this.plugin.saveSettings();
						}
					}));

			new Setting(containerEl)
				.setName('View access logs')
				.setDesc(`Current logs: ${this.plugin.settings.accessLogs.length} entries`)
				.addButton(btn => btn
					.setButtonText('üìñ View Logs')
					.setCta()
					.onClick(() => {
						new AccessLogModal(this.app, this.plugin.settings).open();
					}))
				.addButton(btn => btn
					.setButtonText('üóëÔ∏è Clear All Logs')
					.setWarning()
					.onClick(async () => {
						this.plugin.settings.accessLogs = [];
						await this.plugin.saveSettings();
						new Notice('‚úÖ All access logs cleared');
						this.display();
					}));
		}

		containerEl.createEl('hr');

		new Setting(containerEl)
			.setName('Auto-lock timeout')
			.setDesc('Lock encrypted folders after inactivity (minutes)')
			.addText(text => text
				.setPlaceholder('5')
				.setValue(String(this.plugin.settings.autoLockTimeout))
				.onChange(async (value) => {
					const timeout = parseInt(value);
					if (!isNaN(timeout) && timeout > 0) {
						this.plugin.settings.autoLockTimeout = timeout;
						await this.plugin.saveSettings();
					}
				}));

		new Setting(containerEl)
			.setName('Stealth mode')
			.setDesc('Hide encrypted folders from file explorer when locked')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.showInFileExplorer)
				.onChange(async (value) => {
					this.plugin.settings.showInFileExplorer = value;
					await this.plugin.saveSettings();
				}));

		new Setting(containerEl)
			.setName('Enable biometric unlock')
			.setDesc('Use fingerprint/Face ID on mobile (requires setup)')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.enableBiometric)
				.onChange(async (value) => {
					this.plugin.settings.enableBiometric = value;
					await this.plugin.saveSettings();
				}));

		new Setting(containerEl)
			.setName('Auto backup')
			.setDesc('Automatically backup encrypted folders')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.backupEnabled)
				.onChange(async (value) => {
					this.plugin.settings.backupEnabled = value;
					await this.plugin.saveSettings();
				}));

		new Setting(containerEl)
			.setName('Backup interval')
			.setDesc('How often to create backups (hours)')
			.addText(text => text
				.setPlaceholder('24')
				.setValue(String(this.plugin.settings.backupInterval))
				.onChange(async (value) => {
					const interval = parseInt(value);
					if (!isNaN(interval) && interval > 0) {
						this.plugin.settings.backupInterval = interval;
						await this.plugin.saveSettings();
					}
				}));

		containerEl.createEl('h3', { text: 'üìÇ Encrypted Folders' });

		if (this.plugin.settings.encryptedFolders.length === 0) {
			containerEl.createEl('p', { 
				text: 'No encrypted folders yet. Create one using the command palette.',
				cls: 'setting-item-description'
			});
		} else {
			this.plugin.settings.encryptedFolders.forEach(folder => {
				// Get algorithm from first encrypted file
				let folderAlgorithm = 'Unknown';
				if (folder.encryptedFiles.length > 0) {
					// We'll show the algorithm if we can detect it
					folderAlgorithm = 'Mixed/Auto-detect';
				}
				
				new Setting(containerEl)
					.setName(folder.path)
					.setDesc(`Status: ${folder.isLocked ? 'üîí Locked' : 'üîì Unlocked'} | Files: ${folder.encryptedFiles.length} | Algorithm: Auto-detect`)
					.addButton(btn => btn
						.setButtonText('Remove')
						.setWarning()
						.onClick(async () => {
							this.plugin.settings.encryptedFolders = 
								this.plugin.settings.encryptedFolders.filter(f => f.path !== folder.path);
							await this.plugin.saveSettings();
							this.display();
						}));
			});
		}
	}
}

/**
 * Modal to confirm saving system-picked file to vault
 */
import { Modal } from 'obsidian';

class ConfirmSaveModal extends Modal {
	private onConfirm: (confirmed: boolean) => void;

	constructor(app: App, onConfirm: (confirmed: boolean) => void) {
		super(app);
		this.onConfirm = onConfirm;
	}

	onOpen() {
		const { contentEl } = this;
		contentEl.createEl('h2', { text: 'üíæ Save to Vault?' });

		const description = contentEl.createDiv();
		description.style.cssText = `
			margin-bottom: 20px;
			line-height: 1.6;
		`;
		description.innerHTML = `
			<p>You've selected a key file from your system (outside Obsidian).</p>
			<p><strong>Would you like to save it to your vault for easy access?</strong></p>
			<ul style="margin-left: 20px; color: var(--text-muted);">
				<li>‚úÖ Auto-load on startup</li>
				<li>‚úÖ Available on all devices (if synced)</li>
				<li>‚ö†Ô∏è Stored in vault (less secure than external)</li>
			</ul>
		`;

		const buttonContainer = contentEl.createDiv();
		buttonContainer.style.cssText = `
			display: flex;
			gap: 10px;
			justify-content: flex-end;
		`;

		const noBtn = buttonContainer.createEl('button', { text: 'No, Just Use Once' });
		noBtn.style.cssText = `
			padding: 8px 16px;
			border-radius: 4px;
			cursor: pointer;
		`;
		noBtn.addEventListener('click', () => {
			this.close();
			this.onConfirm(false);
		});

		const yesBtn = buttonContainer.createEl('button', { text: 'Yes, Save to Vault' });
		yesBtn.style.cssText = `
			padding: 8px 16px;
			border-radius: 4px;
			background-color: var(--interactive-accent);
			color: var(--text-on-accent);
			border: none;
			cursor: pointer;
			font-weight: bold;
		`;
		yesBtn.addEventListener('click', () => {
			this.close();
			this.onConfirm(true);
		});
	}

	onClose() {
		const { contentEl } = this;
		contentEl.empty();
	}
}
